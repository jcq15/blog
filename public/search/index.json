[{"content":"记录一下给腾讯云 GPU 服务器安装 tensorflow-gpu 的过程。这玩意事挺多。\n检查必要的东西 检查 Python 版本：\n$ python3  腾讯云自带了 Python3.6。如果没有就装一下。\n验证系统是否有支持 CUDA 的 GPU：\n$ lspci | grep -i nvidia  确认系统已经安装了 gcc：\n$ gcc --version  安装 CUDA 1. 下载 下载 NVIDIA CUDA 工具包，在这找下载链接：\nhttps://developer.nvidia.com/cuda-downloads\n我们装 CUDA Toolkit 11.2 Update 2，target_type 选 runfilelocal 即可。\n2. 安装 首先禁用 Nouveau 驱动\n$ vim /etc/modprobe.d/blacklist-nouveau.conf  如果已有内容就在最后添加，如果是空文件直接输入：\nblacklist nouveau options nouveau modeset=0  然后执行\n$ dracut --force  安装很简单：\n$ sh cuda_\u0026lt;version\u0026gt;_linux.run  输入 accept，之后就一直按 install 与 yes 就行了。执行安装程序会安装自动安装与 CUDA 对应的驱动，所以请不要单独安装驱动。\n3. 设置环境变量 $ vim /etc/profile  文件末尾添加：\nexport PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH export PATH=/usr/local/cuda-11.2/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda-11.2/lib64:$LD_LIBRARY_PATH  执行\n$ source /etc/profile  4. 测试 $ nvcc -V $ nvidia-smi  都能看到输出说明大成功，否则完犊子。\n安装 cudnn https://developer.nvidia.com/rdp/cudnn-archive\n要先注册 nvidia 账号，哈哈。\n然后干就完了：\n$ mv cudnn-\u0026lt;version\u0026gt;.solitairetheme8 cudnn-\u0026lt;version\u0026gt;.tgz $ tar -xzvf cudnn-\u0026lt;version\u0026gt;.tgz $ cp cuda/include/cudnn*.h /usr/local/cuda/include $ cp cuda/lib64/libcudnn* /usr/local/cuda/lib64 $ chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn*  安装 tensorflow-gpu $ pip3 install tensorflow-gpu  然后菜了，报错 python setup.py egg_info failed with error code 1。需要先更新一波 pip：\n$ pip3 install --upgrade setuptools $ python3 -m pip install --upgrade pip  装完了进入 Python，测试一波：\n\u0026gt;\u0026gt;\u0026gt; import tensorflow as tf \u0026gt;\u0026gt;\u0026gt; tf.test.is_gpu_available()  又菜了，他说找不到 libcusolver.so.10。我看了一下，/usr/local/cuda-11.1/lib64/ 里面有个 libcusolver.so.11，好家伙，这不是有病嘛，都 11.2 了还在找 .10，封建遗毒啊！来一个骚操作骗他一手：\n$ ln -s /usr/local/cuda-11.2/lib64/libcusolver.so.11 /usr/local/cuda-11.2/lib64/libcusolver.so.10  然后就好了。\n参考文献 [1] https://blog.csdn.net/qq_35540540/article/details/108767800\n[2] https://github.com/tensorflow/tensorflow/issues/43947#issuecomment-739617116\n","date":"2021-04-02","permalink":"https://blog.shadiao.online/post/centos8/","tags":["技术"],"title":"CentOS 8 配置 tensorflow GPU"},{"content":"（持续更新中）\n序  小孩儿小孩儿你别馋， 过了腊八就是年； 腊八粥，喝几天， 哩哩啦啦二十三； 二十三，糖瓜粘； 二十四，扫房子； 二十五，冻豆腐； 二十六，炖猪肉； 二十七，宰公鸡； 二十八，把面发； 二十九，蒸馒头； 三十晚上熬一宿；\n 正月 大年初一，马勒戈逼； 大年初二，像个傻蛋儿； 大年初三，高位截瘫； 大年初四，不识大字； 大年初五，半截入土； 大年初六，绩点没救； 大年初七，呜呼归西；\n正月初八，房倒屋塌； 正月初九，倒拔垂杨柳； 正月初十，掉进化粪池； 正月十一，变成落汤鸡； 正月十二，出门捡破烂儿；\n","date":"2021-02-24","permalink":"https://blog.shadiao.online/post/daily_poem/","tags":["沙雕"],"title":"每日怪诗——大年初二，像个傻蛋儿"},{"content":"我们经常会用到 Python 的各种库，坠痛苦的就是有一些实用的命令记不住，用的时候只好现查，而且这个效率 efficiency…… 所以啊，我整了这么个速查表，以后直接在这里找就好了。\n本贴会持续更新~\n 注意：本文不是教程，而是速查表。\n 实用工具 datetime import datetime  官方文档：https://docs.python.org/zh-cn/3/library/datetime.html\n日期和时间均用datetime.datetime类的对象表示，所以我们先介绍该类的方法\nnow = datetime.datetime.now() # 当前时间，类型：datetime.datetime now.year # 获取年（int） now.month # 月 # 类似地还有：day, hour, minute, second, microsecond  datetime与字符串之间的转化\n# datetime到字符串用strftime（f是format的意思） now.strftime('%Y-%m-%d %H:%M:%S') # '2020-09-02 17:45:18'，注意大小写 # 字符串到datetime用strptime datetime.datetime.strptime('2020-09-02 17:45:18', '%Y-%m-%d %H:%M:%S') # 这个方法很灵活，根据实际情况来写就行，比如你拿到的数据是'2020年9.2' str_time = '2020年9.2' datetime.datetime.strptime(str_time, '%Y年%m.%d') # 就可以正确生成 # 除了%Y，%m这些，还有许多其他类型的代码，完整格式代码请查看https://docs.python.org/zh-cn/3/library/datetime.html#strftime-and-strptime-format-codes  时间差\n# timedelta类用来处理时间差 a = datetime.datetime.strptime('2020-09-02 17:45:18', '%Y-%m-%d %H:%M:%S') b = datetime.datetime.strptime('2020-09-03 17:46:18', '%Y-%m-%d %H:%M:%S') delta = b - a # 返回timedelta对象 delta.days # 1 delta.seconds # 60 # 注意只有 days. seconds 和 microseconds 会存储在内部，days=1，seconds=60表示这个时间差是1天零60秒，这个结果是唯一的，seconds满一天会自动进位，所以并不会出现days=0，seconds=86460这种情况。  数据处理 numpy 这部分主要整理自 https://cs231n.github.io/python-numpy-tutorial/\nThis tutorial was originally contributed by Justin Johnson\n创建 numpy 的核心是 array，它可以表示高维张量，包括向量（rank=1）、矩阵（rank=2）、三阶张量（rank=3）等。我们有很多种方法创建 array：\nimport numpy as np a = np.array([1, 2, 3]) # 通过list创建array b = np.array([1, 2, 3], [4, 5, 6]) # rank=2，矩阵 print(b) # [[1 2 3] # [4 5 6]] c = np.zeros((2, 2)) # 创建2*2的全0矩阵 d = np.ones((1, 2)) # 1*2的全1矩阵 e = np.full((2, 2), 7) # 2*2，元素都是7 f = np.eye(2) # 2*2单位矩阵 g = np.random.random((2, 2)) # 2*2随机矩阵  索引与切片 可使用list作为下标进行索引，并且支持与python类似的切片操作。\n与list不同的是，array的切片操作返回的是引用，因此修改切片后的值会修改原array的值！\n# Create the following rank 2 array with shape (3, 4) # [[ 1 2 3 4] # [ 5 6 7 8] # [ 9 10 11 12]] a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]]) b = a[:2, 1:3] # [[2 3] # [6 7]]  如果某一维度的索引是 int，array会进行降维。要想避免降维可以使用单个元素的 list：\nrow_r1 = a[1, :] # 矩阵惨遭降维成向量 row_r2 = a[1:2, :] # 如果把1改成1：2，虽然数据一样，但是不降维 row_r3 = a[[1], :] # 用[1]也不降维 print(row_r1, row_r1.shape) print(row_r2, row_r2.shape) print(row_r3, row_r3.shape) # [5 6 7 8] (4,) # [[5 6 7 8]] (1, 4) # [[5 6 7 8]] (1, 4)  切片操作得到的永远是原来 array 的 subarray，如果我想重组怎么办呢？比如 [[1, 2], [3, 4]] 我想得到 [[3, 4], [1, 2], [1, 2]]，可以使用 integer array indexing：\na = np.array([[1, 2], [3, 4]]) b = a[[1, 0, 0], [0, 1]] # b是[[3, 4], [1, 2], [1, 2]]，即a的第1行、第0行、第0行拼接  boolean array indexing 很强大，允许我们进行筛选：\na = np.array([[1,2], [3, 4], [5, 6]]) bool_idx = (a \u0026gt; 2) # Find the elements of a that are bigger than 2; # this returns a numpy array of Booleans of the same # shape as a, where each slot of bool_idx tells # whether that element of a is \u0026gt; 2. # [[False False] # [ True True] # [ True True]] # We use boolean array indexing to construct a rank 1 array # consisting of the elements of a corresponding to the True values # of bool_idx print(a[bool_idx]) # We can do all of the above in a single concise statement: print(a[a \u0026gt; 2]) # [3 4 5 6] # [3 4 5 6]  pandas import pandas as pd # 读取excel，第0个sheet df = pd.read_excel('./filename.xlsx', 0) # 获取行数、列数 nrow = df.shape[0] ncol = df.shape[1] ### 切片、筛选、提取数据 ### # 直接通过'[]'，字符串表示列，数字表示行 df['price'] # 选取名字为'price'的列 df[['name', 'price']]\t# 选取多列，把列名放在list里 df[:2]\t# 第0行和第1行，这里和list的切片操作一样 # iloc和loc：索引用iloc，列名用loc。iloc和loc的优势是可以进行筛选 # loc用法：df.loc[index, column_name] # 一个大坑：loc的行索引是闭区间，而不是python通用的左闭右开（但iloc是正常的） df.loc[2, 'price']\t# 第2行，名字为'price'的列 df.loc[[2,3],['name','price']] # index和column_name都可灵活使用list或切片 df.loc[df['price']\u0026lt;100,'name'] # 筛选，注意筛选条件是针对行的 # iloc用法：只要把loc的列名改成索引 df.iloc[df['price']\u0026lt;100, 2:5] # 一样可以灵活组合list和切片 df.iloc[df['price']\u0026lt;100 | df['price']\u0026gt;200] # 筛选条件'|'表示或，'\u0026amp;'表示与  sklearn # 线性回归 from sklearn import linear_model # 训练数据：X_train, y_train，测试数据：X_test lm = linear_model.LinearRegression() model = lm.fit(X_train, y_train) y_pred = model.predict(X_test) # 交叉验证 from sklearn.model_selection import cross_val_score cross_val_score(m, X, y, cv=5, scoring='neg_mean_squared_error') # 5-fold cross validation, m是sklearn的model  数据结构 heapq import heapq as hq # python的heapq库是在list的基础上添加了堆的操作 # heapq有两种方式创建堆，一种是使用一个空列表，然后使用heapq.heappush()函数把值加入堆中 num = [1,1,4,5,1,4] heapq.heappush(heap, num) # 另外一种就是使用heapq.heapify(list)转换列表成为堆结构 heapq.heapify(num) # 这时候num也变成堆了  网络/爬虫相关 requests import requests # get请求 html = requests.get('www.baidu.com').text # get请求可以优雅地加参数 params = {'q': '搜索测试'} response = requests.get(url='www.google.com/search', params=params).text  BeautifulSoup from bs4 import BeautifulSoup # 之前用request获取html bs = BeautifulSoup(html, 'html.parser') # 查找标签，返回标签html字符串的list p_list = bs.findAll('p')\t# 查找所有\u0026lt;p\u0026gt;标签 div_list = bs.findAll('div', attrs={'class': 'primary'})\t# 带条件筛选\u0026lt;div class='primary'\u0026gt; # 条件可以是正则表达式 a_list = bs.findAll('a', string='[abs]')\t# 字符串包含[abs]  json import json import requests data = requests.get('www.baidu.com').content.decode()\t# 某请求返回的字符串格式的json # 字符串转json data_js = json.loads(data) ","date":"2021-02-22","permalink":"https://blog.shadiao.online/post/python/","tags":["技术"],"title":"Python 速查表"}]